Considering: a Stack and a PathMatcher could be the same thing.  Thinking: the
path passed to Stack could have marked regexp patterns - that becomes * for
fnmatch and regexp.  Stack produces paths with *, we expand those, and match
the expansion against the regexp.  Allows for e.g. Rails style template
finding.  Also an intersection, or just an "item_in?()" method would mean same
class could be used instead of PM for dump/load and merges.

Consequence would be that Stack would have to actually do the searching.
There's also the difference between find and write - write to a match?  Also,
in addition to T->B conscerns, we have L->R (or longest first... or "prefer
matches like").  Or Stack would generate ItemGroups (or PathMatches) which
would themselves have to be iterated.

One solution to "what does it mean to write to a matching pattern" would be:
find the "best" match in any root, then write to that path in the best root.

*** Anything below this line needs review: might be done. ***

Child Sets - often there's an overall Valise, and then parts of the app want to
use only a subdirectory of the set - Valise::Set#child('templates') should
return a facade on the set to read and write files under 'templates'

The facility to treat particular files as if they contain a particular kind of
data (e.g. yaml) has been removed.  I'd like to get that back.  It'd be nice to
open a yaml file and get structured data, manipulate it, and put it back as
yaml.

Even cooler might be to be able to replicate the Ruby require funtionality -
find "settings" and look for settings.yaml, settings.json, settings.xml,
settings.cfg, and manipulate their contents regardless.

Really this is a Metadata feature, although there's a related but orthagonal
behavior to path searching.  First: there's searching by filetype, and
populating by filetype.  Sets might become a convolution of some kind of search
roots and metadata-rulesets.

Which implies config/convention about how to manage both the search and the
population.  I kind of think a "reading English" style convention is probably
correct: l->r,t->b :: filetype,searchroot.  Likewise, DefinedDefaults need a
way to prefer one over the other.

!  The real test case is: I want to populate {:hash => { :of => ["Arrays"]}} -
the population/search preference is for JSON,YAML,XML - and there is a YAML
file in the Set - when do we write hash_of_arrays.json, when do we replace
hash_of_arrays.yaml, etc...

There's also the process of matching a file to a filetype - just extension?

I'm also still not completely convinced of the names used in the API.  Needs a
fresh look, some final decisions, and a final pass.

Some structural refactoring

DOCUMENTATION

A presentation, maybe

Corundumizing


More mundane note, need at least a FileNotFound error
